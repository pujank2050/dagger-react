var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
import * as path from "path";
import * as fs from "fs";
import * as os from "os";
import readline from "readline";
import { execaCommandSync, execaCommand } from "execa";
import Client from "../../api/client.gen.js";
import { DockerImageRefValidationError, EngineSessionPortParseError, InitEngineSessionBinaryError, } from "../../common/errors/index.js";
/**
 * ImageRef is a simple abstraction of docker image reference.
 */
class ImageRef {
    constructor(ref) {
        /**
         * trim image digests to 16 characters to make output more readable.
         */
        this.DIGEST_LEN = 16;
        // Throw error if ref is not correctly formatted.
        ImageRef.validate(ref);
        this.ref = ref;
        const id = ref.split("@sha256:", 2)[1];
        this.id = id.slice(0, this.DIGEST_LEN);
    }
    get Ref() {
        return this.ref;
    }
    get ID() {
        return this.id;
    }
    /**
     * validateImage verify that the passed ref
     * is compliant with DockerImage constructor.
     *
     * This function does not return anything but
     * only throw on error.
     *
     * @throws no digest found in ref.
     */
    static validate(ref) {
        if (!ref.includes("@sha256:")) {
            throw new DockerImageRefValidationError(`no digest found in ref ${ref}`, {
                ref: ref,
            });
        }
    }
}
/**
 * DockerImage is an implementation of EngineConn to set up a Dagger
 * Engine session from a pulled docker image.
 */
export class DockerImage {
    constructor(u) {
        this.cacheDir = path.join(process.env.XDG_CACHE_HOME || path.join(os.homedir(), ".cache"), "dagger");
        this.ENGINE_SESSION_BINARY_PREFIX = "dagger-engine-session";
        this.imageRef = new ImageRef(u.host + u.pathname);
    }
    /**
     * Generate a unix timestamp in nanosecond
     */
    getRandomId() {
        return process.hrtime.bigint().toString();
    }
    Addr() {
        return "http://dagger";
    }
    Connect(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            this.createCacheDir();
            const engineSessionBinPath = this.buildBinPath();
            if (!fs.existsSync(engineSessionBinPath)) {
                this.pullEngineSessionBin(engineSessionBinPath);
            }
            return this.runEngineSession(engineSessionBinPath, opts);
        });
    }
    /**
     * createCacheDir will create a cache directory on user
     * host to store dagger binary.
     *
     * If set, it will use XDG directory, if not, it will use `$HOME/.cache`
     * as base path.
     * Nothing happens if the directory already exists.
     */
    createCacheDir() {
        fs.mkdirSync(this.cacheDir, { mode: 0o700, recursive: true });
    }
    /**
     * buildBinPath create a path to output engine session binary.
     *
     * It will store it in the cache directory with a name composed
     * of the base engine session as constant and the engine identifier.
     */
    buildBinPath() {
        const binPath = `${this.cacheDir}/${this.ENGINE_SESSION_BINARY_PREFIX}-${this.imageRef.ID}`;
        switch (this.normalizedOS()) {
            case "windows":
                return `${binPath}.exe`;
            default:
                return binPath;
        }
    }
    /**
     * normalizedArch returns the architecture name used by the rest of our SDKs.
     */
    normalizedArch() {
        switch (os.arch()) {
            case "x64":
                return "amd64";
            default:
                return os.arch();
        }
    }
    /**
     * normalizedOS returns the os name used by the rest of our SDKs.
     */
    normalizedOS() {
        switch (os.platform()) {
            case "win32":
                return "windows";
            default:
                return os.platform();
        }
    }
    /**
     * pullEngineSessionBin will retrieve Dagger binary from its docker image
     * and copy it to the local host.
     * This function automatically resolves host's platform to copy the correct
     * binary.
     */
    pullEngineSessionBin(engineSessionBinPath) {
        // Create a temporary bin file path
        const tmpBinPath = path.join(this.cacheDir, `temp-${this.ENGINE_SESSION_BINARY_PREFIX}-${this.getRandomId()}`);
        const dockerRunArgs = [
            "docker",
            "run",
            "--rm",
            "--entrypoint",
            "/bin/cat",
            this.imageRef.Ref,
            `/usr/bin/${this.ENGINE_SESSION_BINARY_PREFIX}-${this.normalizedOS()}-${this.normalizedArch()}`,
        ];
        try {
            const fd = fs.openSync(tmpBinPath, "w", 0o700);
            execaCommandSync(dockerRunArgs.join(" "), {
                stdout: fd,
                stderr: "pipe",
                encoding: null,
                // Kill the process if parent exit.
                cleanup: true,
                // Throw on error
                reject: true,
                timeout: 300000,
            });
            fs.closeSync(fd);
            fs.renameSync(tmpBinPath, engineSessionBinPath);
        }
        catch (e) {
            fs.rmSync(tmpBinPath);
            throw new InitEngineSessionBinaryError(`failed to copy engine session binary: ${e}`, { cause: e });
        }
        // Remove all temporary binary files
        // Ignore current engine session binary or other files that have not be
        // created by this SDK.
        try {
            const files = fs.readdirSync(this.cacheDir);
            files.forEach((file) => {
                const filePath = `${this.cacheDir}/${file}`;
                if (filePath === engineSessionBinPath ||
                    !file.startsWith(this.ENGINE_SESSION_BINARY_PREFIX)) {
                    return;
                }
                fs.unlinkSync(filePath);
            });
        }
        catch (e) {
            // Log the error but do not interrupt program.
            console.error("could not clean up temporary binary files");
        }
    }
    /**
     * runEngineSession execute the engine binary and set up a GraphQL client that
     * target this engine.
     */
    runEngineSession(engineSessionBinPath, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const env = process.env;
            if (!env.DAGGER_RUNNER_HOST) {
                env.DAGGER_RUNNER_HOST = `docker-image://${this.imageRef.Ref}`;
            }
            const engineSessionArgs = [engineSessionBinPath];
            if (opts.Workdir) {
                engineSessionArgs.push("--workdir", opts.Workdir);
            }
            if (opts.Project) {
                engineSessionArgs.push("--project", opts.Project);
            }
            this.subProcess = execaCommand(engineSessionArgs.join(" "), {
                stderr: opts.LogOutput || "ignore",
                // Kill the process if parent exit.
                cleanup: true,
                env: env,
            });
            const stdoutReader = readline.createInterface({
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                input: this.subProcess.stdout,
            });
            const port = yield Promise.race([
                this.readPort(stdoutReader),
                new Promise((_, reject) => {
                    setTimeout(() => {
                        reject(new EngineSessionPortParseError("timeout reading port from engine session"));
                    }, 300000).unref(); // long timeout to account for extensions, though that should be optimized in future
                }),
            ]);
            return new Client({ host: `127.0.0.1:${port}` });
        });
    }
    readPort(stdoutReader) {
        var _a, stdoutReader_1, stdoutReader_1_1;
        var _b, e_1, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                for (_a = true, stdoutReader_1 = __asyncValues(stdoutReader); stdoutReader_1_1 = yield stdoutReader_1.next(), _b = stdoutReader_1_1.done, !_b;) {
                    _d = stdoutReader_1_1.value;
                    _a = false;
                    try {
                        const line = _d;
                        // Read line as a port number
                        const port = parseInt(line);
                        if (isNaN(port)) {
                            throw new EngineSessionPortParseError(`failed to parse port from engine session while parsing: ${line}`, { parsedLine: line });
                        }
                        return port;
                    }
                    finally {
                        _a = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_a && !_b && (_c = stdoutReader_1.return)) yield _c.call(stdoutReader_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            throw new EngineSessionPortParseError("No line was found to parse the engine port");
        });
    }
    Close() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if ((_a = this.subProcess) === null || _a === void 0 ? void 0 : _a.pid) {
                this.subProcess.kill("SIGTERM", {
                    forceKillAfterTimeout: 2000,
                });
            }
        });
    }
}

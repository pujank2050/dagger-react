/**
 * This file was auto-generated by `cloak clientgen`.
 * Do not make direct changes to the file.
 */
import { GraphQLClient } from "graphql-request";
/**
 * @hidden
 */
export type QueryTree = {
    operation: string;
    args?: Record<string, unknown>;
};
interface ClientConfig {
    queryTree?: QueryTree[];
    host?: string;
}
declare class BaseClient {
    protected _queryTree: QueryTree[];
    protected client: GraphQLClient;
    /**
     * @defaultValue `127.0.0.1:8080`
     */
    clientHost: string;
    /**
     * @hidden
     */
    constructor({ queryTree, host }?: ClientConfig);
    /**
     * @hidden
     */
    get queryTree(): QueryTree[];
}
/**
 * A global cache volume identifier
 */
export type CacheID = string;
export type ContainerBuildOpts = {
    dockerfile?: string;
};
export type ContainerExecOpts = {
    /**
     * Command to run instead of the container's default command
     */
    args?: string[];
    /**
     * Content to write to the command's standard input before closing
     */
    stdin?: string;
    /**
     * Redirect the command's standard output to a file in the container
     */
    redirectStdout?: string;
    /**
     * Redirect the command's standard error to a file in the container
     */
    redirectStderr?: string;
    /**
     * Provide dagger access to the executed command
     * Do not use this option unless you trust the command being executed
     * The command being executed WILL BE GRANTED FULL ACCESS TO YOUR HOST FILESYSTEM
     */
    experimentalPrivilegedNesting?: boolean;
};
export type ContainerExportOpts = {
    platformVariants?: ContainerID[] | Container[];
};
export type ContainerPublishOpts = {
    platformVariants?: ContainerID[] | Container[];
};
export type ContainerWithDefaultArgsOpts = {
    args?: string[];
};
export type ContainerWithDirectoryOpts = {
    exclude?: string[];
    include?: string[];
};
export type ContainerWithExecOpts = {
    /**
     * Content to write to the command's standard input before closing
     */
    stdin?: string;
    /**
     * Redirect the command's standard output to a file in the container
     */
    redirectStdout?: string;
    /**
     * Redirect the command's standard error to a file in the container
     */
    redirectStderr?: string;
    /**
     * Provide dagger access to the executed command
     * Do not use this option unless you trust the command being executed
     * The command being executed WILL BE GRANTED FULL ACCESS TO YOUR HOST FILESYSTEM
     */
    experimentalPrivilegedNesting?: boolean;
};
export type ContainerWithMountedCacheOpts = {
    source?: DirectoryID | Directory;
};
export type ContainerWithNewFileOpts = {
    contents?: string;
};
/**
 * A unique container identifier. Null designates an empty container (scratch).
 */
export type ContainerID = string;
/**
 * The `DateTime` scalar type represents a DateTime. The DateTime is serialized as an RFC 3339 quoted string
 */
export type DateTime = string;
export type DirectoryDockerBuildOpts = {
    dockerfile?: string;
    platform?: Platform;
};
export type DirectoryEntriesOpts = {
    path?: string;
};
export type DirectoryWithDirectoryOpts = {
    exclude?: string[];
    include?: string[];
};
/**
 * A content-addressed directory identifier
 */
export type DirectoryID = string;
export type FileID = string;
export type GitRefTreeOpts = {
    sshKnownHosts?: string;
    sshAuthSocket?: SocketID;
};
export type HostDirectoryOpts = {
    exclude?: string[];
    include?: string[];
};
export type HostWorkdirOpts = {
    exclude?: string[];
    include?: string[];
};
/**
 * The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
 */
export type ID = string;
export type Platform = string;
export type ClientContainerOpts = {
    id?: ContainerID | Container;
    platform?: Platform;
};
export type ClientDirectoryOpts = {
    id?: DirectoryID | Directory;
};
export type ClientGitOpts = {
    keepGitDir?: boolean;
};
export type ClientSocketOpts = {
    id?: SocketID;
};
/**
 * A unique identifier for a secret
 */
export type SecretID = string;
/**
 * A content-addressed socket identifier
 */
export type SocketID = string;
export type __TypeEnumValuesOpts = {
    includeDeprecated?: boolean;
};
export type __TypeFieldsOpts = {
    includeDeprecated?: boolean;
};
/**
 * A directory whose contents persist across runs
 */
export declare class CacheVolume extends BaseClient {
    id(): Promise<CacheID>;
}
/**
 * An OCI-compatible container, also known as a docker container
 */
export declare class Container extends BaseClient {
    /**
     * Initialize this container from a Dockerfile build
     */
    build(context: DirectoryID | Directory, opts?: ContainerBuildOpts): Container;
    /**
     * Default arguments for future commands
     */
    defaultArgs(): Promise<string[]>;
    /**
     * Retrieve a directory at the given path. Mounts are included.
     */
    directory(path: string): Directory;
    /**
     * Entrypoint to be prepended to the arguments of all commands
     */
    entrypoint(): Promise<string[]>;
    /**
     * The value of the specified environment variable
     */
    envVariable(name: string): Promise<string>;
    /**
     * A list of environment variables passed to commands
     */
    envVariables(): Promise<EnvVariable[]>;
    /**
     * This container after executing the specified command inside it
     *
     * @param opts optional params for exec
     *
     * @deprecated Replaced by withExec.
     */
    exec(opts?: ContainerExecOpts): Container;
    /**
     * Exit code of the last executed command. Zero means success.
     * Null if no command has been executed.
     */
    exitCode(): Promise<number>;
    /**
     * Write the container as an OCI tarball to the destination file path on the host
     */
    export(path: string, opts?: ContainerExportOpts): Promise<boolean>;
    /**
     * Retrieve a file at the given path. Mounts are included.
     */
    file(path: string): File;
    /**
     * Initialize this container from the base image published at the given address
     */
    from(address: string): Container;
    /**
     * This container's root filesystem. Mounts are not included.
     *
     *
     * @deprecated Replaced by rootfs.
     */
    fs(): Directory;
    /**
     * A unique identifier for this container
     */
    id(): Promise<ContainerID>;
    /**
     * List of paths where a directory is mounted
     */
    mounts(): Promise<string[]>;
    /**
     * The platform this container executes and publishes as
     */
    platform(): Promise<Platform>;
    /**
     * Publish this container as a new image, returning a fully qualified ref
     */
    publish(address: string, opts?: ContainerPublishOpts): Promise<string>;
    /**
     * This container's root filesystem. Mounts are not included.
     */
    rootfs(): Directory;
    /**
     * The error stream of the last executed command.
     * Null if no command has been executed.
     */
    stderr(): Promise<string>;
    /**
     * The output stream of the last executed command.
     * Null if no command has been executed.
     */
    stdout(): Promise<string>;
    /**
     * The user to be set for all commands
     */
    user(): Promise<string>;
    /**
     * Configures default arguments for future commands
     */
    withDefaultArgs(opts?: ContainerWithDefaultArgsOpts): Container;
    /**
     * This container plus a directory written at the given path
     */
    withDirectory(path: string, directory: DirectoryID | Directory, opts?: ContainerWithDirectoryOpts): Container;
    /**
     * This container but with a different command entrypoint
     */
    withEntrypoint(args: string[]): Container;
    /**
     * This container plus the given environment variable
     */
    withEnvVariable(name: string, value: string): Container;
    /**
     * This container after executing the specified command inside it
     */
    withExec(args: string[], opts?: ContainerWithExecOpts): Container;
    /**
     * Initialize this container from this DirectoryID
     *
     *
     * @deprecated Replaced by withRootfs.
     */
    withFS(id: DirectoryID | Directory): Container;
    /**
     * This container plus the contents of the given file copied to the given path
     */
    withFile(path: string, source: FileID | File): Container;
    /**
     * This container plus a cache volume mounted at the given path
     */
    withMountedCache(path: string, cache: CacheID | CacheVolume, opts?: ContainerWithMountedCacheOpts): Container;
    /**
     * This container plus a directory mounted at the given path
     */
    withMountedDirectory(path: string, source: DirectoryID | Directory): Container;
    /**
     * This container plus a file mounted at the given path
     */
    withMountedFile(path: string, source: FileID | File): Container;
    /**
     * This container plus a secret mounted into a file at the given path
     */
    withMountedSecret(path: string, source: SecretID | Secret): Container;
    /**
     * This container plus a temporary directory mounted at the given path
     */
    withMountedTemp(path: string): Container;
    /**
     * This container plus a new file written at the given path
     */
    withNewFile(path: string, opts?: ContainerWithNewFileOpts): Container;
    /**
     * Initialize this container from this DirectoryID
     */
    withRootfs(id: DirectoryID | Directory): Container;
    /**
     * This container plus an env variable containing the given secret
     */
    withSecretVariable(name: string, secret: SecretID | Secret): Container;
    /**
     * This container plus a socket forwarded to the given Unix socket path
     */
    withUnixSocket(path: string, source: SocketID): Container;
    /**
     * This container but with a different command user
     */
    withUser(name: string): Container;
    /**
     * This container but with a different working directory
     */
    withWorkdir(path: string): Container;
    /**
     * This container minus the given environment variable
     */
    withoutEnvVariable(name: string): Container;
    /**
     * This container after unmounting everything at the given path.
     */
    withoutMount(path: string): Container;
    /**
     * This container with a previously added Unix socket removed
     */
    withoutUnixSocket(path: string): Container;
    /**
     * The working directory for all commands
     */
    workdir(): Promise<string>;
}
/**
 * A directory
 */
export declare class Directory extends BaseClient {
    /**
     * The difference between this directory and an another directory
     */
    diff(other: DirectoryID | Directory): Directory;
    /**
     * Retrieve a directory at the given path
     */
    directory(path: string): Directory;
    /**
     * Build a new Docker container from this directory
     */
    dockerBuild(opts?: DirectoryDockerBuildOpts): Container;
    /**
     * Return a list of files and directories at the given path
     */
    entries(opts?: DirectoryEntriesOpts): Promise<string[]>;
    /**
     * Write the contents of the directory to a path on the host
     */
    export(path: string): Promise<boolean>;
    /**
     * Retrieve a file at the given path
     */
    file(path: string): File;
    /**
     * The content-addressed identifier of the directory
     */
    id(): Promise<DirectoryID>;
    /**
     * load a project's metadata
     */
    loadProject(configPath: string): Project;
    /**
     * This directory plus a directory written at the given path
     */
    withDirectory(path: string, directory: DirectoryID | Directory, opts?: DirectoryWithDirectoryOpts): Directory;
    /**
     * This directory plus the contents of the given file copied to the given path
     */
    withFile(path: string, source: FileID | File): Directory;
    /**
     * This directory plus a new directory created at the given path
     */
    withNewDirectory(path: string): Directory;
    /**
     * This directory plus a new file written at the given path
     */
    withNewFile(path: string, contents: string): Directory;
    /**
     * This directory with the directory at the given path removed
     */
    withoutDirectory(path: string): Directory;
    /**
     * This directory with the file at the given path removed
     */
    withoutFile(path: string): Directory;
}
/**
 * EnvVariable is a simple key value object that represents an environment variable.
 */
export declare class EnvVariable extends BaseClient {
    /**
     * name is the environment variable name.
     */
    name(): Promise<string>;
    /**
     * value is the environment variable value
     */
    value(): Promise<string>;
}
/**
 * A file
 */
export declare class File extends BaseClient {
    /**
     * The contents of the file
     */
    contents(): Promise<string>;
    /**
     * Write the file to a file path on the host
     */
    export(path: string): Promise<boolean>;
    /**
     * The content-addressed identifier of the file
     */
    id(): Promise<FileID>;
    secret(): Secret;
    /**
     * The size of the file, in bytes
     */
    size(): Promise<number>;
}
/**
 * A git ref (tag or branch)
 */
export declare class GitRef extends BaseClient {
    /**
     * The digest of the current value of this ref
     */
    digest(): Promise<string>;
    /**
     * The filesystem tree at this ref
     */
    tree(opts?: GitRefTreeOpts): Directory;
}
/**
 * A git repository
 */
export declare class GitRepository extends BaseClient {
    /**
     * Details on one branch
     */
    branch(name: string): GitRef;
    /**
     * List of branches on the repository
     */
    branches(): Promise<string[]>;
    /**
     * Details on one commit
     */
    commit(id: string): GitRef;
    /**
     * Details on one tag
     */
    tag(name: string): GitRef;
    /**
     * List of tags on the repository
     */
    tags(): Promise<string[]>;
}
/**
 * Information about the host execution environment
 */
export declare class Host extends BaseClient {
    /**
     * Access a directory on the host
     */
    directory(path: string, opts?: HostDirectoryOpts): Directory;
    /**
     * Access an environment variable on the host
     */
    envVariable(name: string): HostVariable;
    /**
     * Access a Unix socket on the host
     */
    unixSocket(path: string): Socket;
    /**
     * The current working directory on the host
     *
     * @param opts optional params for workdir
     *
     * @deprecated Use directory with path set to '.' instead.
     */
    workdir(opts?: HostWorkdirOpts): Directory;
}
/**
 * An environment variable on the host environment
 */
export declare class HostVariable extends BaseClient {
    /**
     * A secret referencing the value of this variable
     */
    secret(): Secret;
    /**
     * The value of this variable
     */
    value(): Promise<string>;
}
/**
 * A set of scripts and/or extensions
 */
export declare class Project extends BaseClient {
    /**
     * extensions in this project
     */
    extensions(): Promise<Project[]>;
    /**
     * Code files generated by the SDKs in the project
     */
    generatedCode(): Directory;
    /**
     * install the project's schema
     */
    install(): Promise<boolean>;
    /**
     * name of the project
     */
    name(): Promise<string>;
    /**
     * schema provided by the project
     */
    schema(): Promise<string>;
    /**
     * sdk used to generate code for and/or execute this project
     */
    sdk(): Promise<string>;
}
export default class Client extends BaseClient {
    /**
     * Construct a cache volume for a given cache key
     */
    cacheVolume(key: string): CacheVolume;
    /**
     * Load a container from ID.
     * Null ID returns an empty container (scratch).
     * Optional platform argument initializes new containers to execute and publish as that platform. Platform defaults to that of the builder's host.
     */
    container(opts?: ClientContainerOpts): Container;
    /**
     * The default platform of the builder.
     */
    defaultPlatform(): Promise<Platform>;
    /**
     * Load a directory by ID. No argument produces an empty directory.
     */
    directory(opts?: ClientDirectoryOpts): Directory;
    /**
     * Load a file by ID
     */
    file(id: FileID | File): File;
    /**
     * Query a git repository
     */
    git(url: string, opts?: ClientGitOpts): GitRepository;
    /**
     * Query the host environment
     */
    host(): Host;
    /**
     * An http remote
     */
    http(url: string): File;
    /**
     * Look up a project by name
     */
    project(name: string): Project;
    /**
     * Load a secret from its ID
     */
    secret(id: SecretID | Secret): Secret;
    /**
     * Load a socket by ID
     */
    socket(opts?: ClientSocketOpts): Socket;
}
/**
 * A reference to a secret value, which can be handled more safely than the value itself
 */
export declare class Secret extends BaseClient {
    /**
     * The identifier for this secret
     */
    id(): Promise<SecretID>;
    /**
     * The value of this secret
     */
    plaintext(): Promise<string>;
}
export declare class Socket extends BaseClient {
    /**
     * The content-addressed identifier of the socket
     */
    id(): Promise<SocketID>;
}
export {};
//# sourceMappingURL=client.gen.d.ts.map
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/* eslint-disable @typescript-eslint/no-explicit-any */
import { ClientError, gql } from "graphql-request";
import { GraphQLRequestError, TooManyNestedObjectsError, UnknownDaggerError, } from "../common/errors/index.js";
function buildArgs(item) {
    const entries = Object.entries(item.args)
        .filter((value) => value[1] !== undefined)
        .map((value) => {
        return `${value[0]}: ${JSON.stringify(value[1]).replace(/\{"[a-zA-Z]+"/gi, (str) => str.replace(/"/g, ""))}`;
    });
    if (entries.length === 0) {
        return "";
    }
    return "(" + entries + ")";
}
/**
 * Find querytree, convert them into GraphQl query
 * then compute and return the result to the appropriate field
 */
function computeNestedQuery(query, client) {
    return __awaiter(this, void 0, void 0, function* () {
        /**
         * Check if there is a nested queryTree to be executed
         */
        const isQueryTree = (value) => Object.keys(value).find((val) => val === "_queryTree");
        for (const q of query) {
            if (q.args !== undefined) {
                yield Promise.all(Object.entries(q.args).map((val) => __awaiter(this, void 0, void 0, function* () {
                    if (val[1] instanceof Object && isQueryTree(val[1])) {
                        // push an id that will be used by the container
                        const getQueryTree = buildQuery([
                            ...val[1]["_queryTree"],
                            {
                                operation: "id",
                            },
                        ]);
                        const result = yield compute(getQueryTree, client);
                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                        //@ts-ignore
                        q.args[val[0]] = result;
                    }
                })));
            }
        }
    });
}
/**
 * Convert the queryTree into a GraphQL query
 * @param q
 * @returns
 */
export function buildQuery(q) {
    let query = "{";
    q.forEach((item, index) => {
        query += `
        ${item.operation} ${item.args ? `${buildArgs(item)}` : ""} ${q.length - 1 !== index ? "{" : "}".repeat(q.length - 1)}
      `;
    });
    query += "}";
    return query;
}
/**
 * Convert querytree into a Graphql query then compute it
 * @param q | QueryTree[]
 * @param client | GraphQLClient
 * @returns
 */
export function queryBuilder(q, client) {
    return __awaiter(this, void 0, void 0, function* () {
        yield computeNestedQuery(q, client);
        const query = buildQuery(q);
        const result = yield compute(query, client);
        return result;
    });
}
/**
 * Return a Graphql query result flattened
 * @param response any
 * @returns
 */
export function queryFlatten(response) {
    // Recursion break condition
    // If our response is not an object or an array we assume we reached the value
    if (!(response instanceof Object) || Array.isArray(response)) {
        return response;
    }
    const keys = Object.keys(response);
    if (keys.length != 1) {
        // Dagger is currently expecting to only return one value
        // If the response is nested in a way were more than one object is nested inside throw an error
        throw new TooManyNestedObjectsError("Too many nested objects inside graphql response", { response: response });
    }
    const nestedKey = keys[0];
    return queryFlatten(response[nestedKey]);
}
/**
 * Send a GraphQL document to the server
 * return a flatten result
 * @hidden
 */
export function compute(query, client) {
    return __awaiter(this, void 0, void 0, function* () {
        let computeQuery;
        try {
            computeQuery = yield client.request(gql `
        ${query}
      `);
        }
        catch (e) {
            if (e instanceof ClientError) {
                throw new GraphQLRequestError("Error message", {
                    request: e.request,
                    response: e.response,
                    cause: e,
                });
            }
            // Just throw the unknown error
            throw new UnknownDaggerError("Encountered an unknown error while requesting data via graphql", { cause: e });
        }
        return queryFlatten(computeQuery);
    });
}
